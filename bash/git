# aliases
alias g=git

# bash completion
[[ -r "/usr/local/etc/profile.d/bash_completion.sh" ]] && . "/usr/local/etc/profile.d/bash_completion.sh"

# functions
function rebase {
  local remote_branch=$(get_remote)
  git fetch origin && git rebase $remote_branch
}

function merge {
  local skip_lint=false
  local msg

  while (( "$#" )); do
    if [[ $1 == '--skip-lint' ]]; then
      skip_lint=true
    else
      msg=$1
    fi
    shift
  done

  if [[ $msg == "" ]]; then
    msg=$(g l -n 1 --oneline | cut -d " " -f 2-)
    echo "using last commit message: $msg"
  fi

  rebase

  has_linter=$(yarn run 2> /dev/null | grep -q '\- lint'; echo $?)
  if [[ $skip_lint != true ]] && [[ $has_linter == "0" ]]; then
    yarn lint
    if [[ $? != "0" ]] && [[ $skip_lint != true ]]; then
      return
    fi
  fi

  local remote_branch=$(get_remote)
  local components
  IFS="/" read -ra components <<< $remote_branch
  remote_name=${components[0]}
  remote_branch_name=${components[1]}

  timedatectl set-timezone 'Africa/Lagos' && \
    yarn test && \
    timedatectl set-timezone 'America/Edmonton' && \
    git -c advice.detachedHead=false checkout $remote_branch && \
    git merge --squash - && \
    git commit -m "$msg" && \
    git push ${remote_name} HEAD:${remote_branch_name} && \
    git branch -f @{-1} && \
    git checkout - && \
    rg -i 'todo.*tolu'
}

function get_remote {
  local commit
  local remote

  for commit in $(git log --pretty=format:"%h"); do
    remote=$(g branch -r --contains $commit)
    if [[ $remote ]]; then break; fi
  done

  if [[ ! $commit ]]; then
    echo "could not find a remote branch to match current branch"
    return
  fi

  echo $remote | grep -oP "origin/[^(HEAD)]+" | cut -d " " -f 1
}
